
// ScoreCell.h
// ofxPDSP
// Nicola Pisanti, MIT License, 2016

#ifndef PDSP_SCORECELL_H_INCLUDED
#define PDSP_SCORECELL_H_INCLUDED

#include "../flags.h"
#include <vector>
#include <algorithm>
#include <assert.h>
#include "../DSP/pdspFunctions.h"

namespace pdsp{

//---------------------------------------------------------------------------
    /*!
    @brief Basic message block for scoring.
    
    This class rapresent a message contained inside the vector of a ScoreCell, having a time of execution, a value that will be interpreted by GateSequencer or ValueSequencer and the index of the output lane choosen between the one available of the ScoreSection that contains the ScoreCell.

    */ 
class ScoreMessage{
public:

    /*!
    @brief default values are time = 0.0, value = 0.0f, lane = 0
    */ 
    ScoreMessage();
    
    /*!
    @brief for this constructor lane = 0
    */ 
    ScoreMessage(double time, float value );
    
    ScoreMessage(double time, float value, int lane);
    ScoreMessage(const ScoreMessage &other);
    ScoreMessage& operator= (const ScoreMessage &other);
    ~ScoreMessage();
    /*!
    @brief time in bars of the execution, relative to the ScoreCell start
    */     
    double   time;    
    /*!
    @brief value to be output. GateSequencer and ValueSequencer interpret the received value in different manners.
    
    Value to be output. GateSequencer and ValueSequencer interpret the received value in different manners. GateSequencer emits a trigger on for values > 0.0f and a trigger off for value <= 0.0f. ValueSequencer constantly outputs a value, the sequenced value is changed at the right time, eventually the change is slewed if the slew is active.
    */     
    float    value;
    /*!
    @brief  the index of the output lane choosen between the one available of the ScoreSection that contains the ScoreCell.
    */     
    int      lane;
};


bool messageSort(const ScoreMessage &lhs, const ScoreMessage &rhs );


//---------------------------------------------------------------------------


    /*!
    @brief Basic building block for scoring.
    
    This abstract class rapresents an algorithm to generate messages and a vector to contain those messages, that will be read by a ScoreSection and sent to GateSequencer or ValueSequencer, turning those messages in buffers for controlling the DSPs.

    */ 

class ScoreCell{
    friend class ScoreSection;

public:
    ScoreCell();
    virtual ~ScoreCell(){};
      
      
    /*!
    @brief time in bars before the next ScoreCell will be launched. Messages with a time greater than this won't be played.
    */  
    double length;
      
    /*!
    @brief this is the vector containing the score, the ScoreMessage instances present in the vector will be played. Warning: before being used, after being generated by generateScore(), the vector will be sorted by time values.
    */ 
    std::vector<ScoreMessage> score;
    
protected:


    /*!
    @brief generate the pattern

    In this method you can call addMessage() or setMessage() to change the values of the message vector. This method is called inside the audio callback when a pattern is "triggered" so keep it really cheap on the cpu.
    */ 
    virtual void generateScore() noexcept; 
    
    
    /*!
    @brief prepare the pattern

    In this method you can call addMessage() or setMessage() to change the values of the message vector. This method is called inside the audio callback when another pattern is triggered and this pattern is next in line to be launched, so you potentally have the time to create another thread for making some extra processing and have the results ready for when the pattern have to be launched.
    */ 
    virtual void prepareScore() noexcept;    


    
private:



    void executeGenerateScore();
    void executePrepareScore();
    

};

//---------------------------------------------------------------------------

    /*!
    @brief Build block for automatically sequencing ScoreCell
    
    This abstract class rapresents an algorithm to choice the ScoreCell to play next when a ScoreCell is triggered.
    Behavior class contains some already implemented CellChange.
    */ 
class CellChange{
public:
    virtual ~CellChange(){};
    
    /*!
    @brief Algorithm to choice the next pattern.
    @param[in] currentPattern index of the current pattern
    @param[in] size size of the ScoreCell vector
    
    This is the algorithm to choice the ScoreCell to play next when a ScoreCell is triggered. Having the current index and the size of the available ScoreCell you can return the new index. Obviously new index have to be >=0 and <size
    */ 
    virtual int getNextPattern( int currentPattern, int size ) =0;
};


}//END NAMESPACE


#endif //PDSP_SCORECELL_H_INCLUDED
